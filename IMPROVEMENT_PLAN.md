# ğŸ¯ ã‚·ã‚¹ãƒ†ãƒ æ”¹å–„è¨ˆç”»æ›¸

## ã‚¢ãƒ‰ãƒã‚¤ã‚¹åˆ†æçµæœ

### ç›®æ¨™
- **çš„ä¸­ç‡**: 40ã€œ55%ï¼ˆAIé¸å®šãƒ¬ãƒ¼ã‚¹å†…ï¼‰
- **å›åç‡**: 110ã€œ130%
- **æ‰‹æ³•**: 2æ®µéšãƒ¢ãƒ‡ãƒ« + KellyåŸºæº–æŠ•è³‡æˆ¦ç•¥

---

## ğŸ“Š ç¾çŠ¶è©•ä¾¡

### âœ… æ—¢ã«å®Ÿè£…æ¸ˆã¿
1. **ãƒ‡ãƒ¼ã‚¿åŸºç›¤**
   - SQLiteãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹
   - é¸æ‰‹ãƒ»ãƒ¢ãƒ¼ã‚¿ãƒ¼ãƒ»ãƒ¬ãƒ¼ã‚¹çµæœãƒ‡ãƒ¼ã‚¿
   - å¤©å€™ãƒ»å±•ç¤ºã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿
   - æ½®æ±ãƒ‡ãƒ¼ã‚¿

2. **ç‰¹å¾´é‡ï¼ˆåŸºæœ¬ï¼‰**
   - é¸æ‰‹å‹ç‡ã€ç´šåˆ¥
   - ãƒ¢ãƒ¼ã‚¿ãƒ¼ãƒ»ãƒœãƒ¼ãƒˆé€£å¯¾ç‡
   - å±•ç¤ºã‚¿ã‚¤ãƒ ã€STã‚¿ã‚¤ãƒŸãƒ³ã‚°
   - ã‚³ãƒ¼ã‚¹åˆ¥æˆç¸¾
   - å ´æ‰€åˆ¥æˆç¸¾

3. **ãƒ¢ãƒ‡ãƒ«åŸºç›¤**
   - XGBoostãƒ¢ãƒ‡ãƒ«
   - SHAPèª¬æ˜å¯èƒ½æ€§
   - ãƒ¢ãƒ‡ãƒ«ä¿å­˜ãƒ»èª­ã¿è¾¼ã¿æ©Ÿèƒ½

4. **UI**
   - Streamlit UI
   - ãƒ‡ãƒ¼ã‚¿åé›†ãƒ»ç®¡ç†æ©Ÿèƒ½
   - é¸æ‰‹è©³ç´°åˆ†æ
   - å ´æ”»ç•¥åˆ†æ

### âš ï¸ æœªå®Ÿè£…ãƒ»æ”¹å–„å¿…è¦

1. **2æ®µéšãƒ¢ãƒ‡ãƒ«ï¼ˆæœ€é‡è¦ï¼ï¼‰**
   - âŒ Stage1: ãƒ¬ãƒ¼ã‚¹é¸åˆ¥ãƒ¢ãƒ‡ãƒ«
   - âŒ Stage2: ç€é †äºˆæ¸¬ãƒ¢ãƒ‡ãƒ«

2. **æŠ•è³‡æˆ¦ç•¥**
   - âŒ æœŸå¾…å€¤ãƒ™ãƒ¼ã‚¹ã®è³¼å…¥åˆ¤å®š
   - âŒ KellyåŸºæº–ã§ã®è³‡é‡‘é…åˆ†
   - âŒ ãƒªã‚¹ã‚¯èª¿æ•´æ©Ÿèƒ½

3. **ç‰¹å¾´é‡å¼·åŒ–**
   - âŒ ãƒ¬ãƒ¼ã‚¹å†…å±•ç¤ºé †ä½ï¼ˆexh_rank_in_raceï¼‰
   - âŒ Target Encoding
   - âŒ Frequency Encoding
   - âŒ æ½®æ±ã®ç›¸å¯¾çš„å½±éŸ¿ï¼ˆtide_relï¼‰

4. **ãƒ¢ãƒ‡ãƒ«æ”¹å–„**
   - âŒ ç¢ºç‡æ ¡æ­£ï¼ˆCalibrationï¼‰
   - âŒ æ™‚ç³»åˆ—K-fold CV
   - âŒ LightGBMå¯¾å¿œ

5. **è©•ä¾¡æŒ‡æ¨™**
   - âŒ Precision@K, Recall@K
   - âŒ æœˆæ¬¡ROI
   - âŒ æœ€å¤§ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³

6. **é‹ç”¨æ©Ÿèƒ½**
   - âŒ é€±æ¬¡è‡ªå‹•å†å­¦ç¿’
   - âŒ A/Bãƒ†ã‚¹ãƒˆæ©Ÿèƒ½
   - âŒ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°

---

## ğŸ¯ å®Ÿè£…å„ªå…ˆé †ä½

### ã€Phase 1ã€‘æœ€å„ªå…ˆï¼ˆ2é€±é–“ï¼‰

#### 1.1 Stage1: ãƒ¬ãƒ¼ã‚¹é¸åˆ¥ãƒ¢ãƒ‡ãƒ«ï¼ˆ1é€±é–“ï¼‰
**ç›®çš„**: äºˆæƒ³ã—ã‚„ã™ã„ãƒ¬ãƒ¼ã‚¹ã‚’é¸ã¶

**å®Ÿè£…å†…å®¹**:
```python
# src/ml/race_selector.py
class RaceSelector:
    """
    ãƒ¬ãƒ¼ã‚¹é¸åˆ¥ãƒ¢ãƒ‡ãƒ«ï¼ˆStage1ï¼‰

    å‡ºåŠ›: buy_scoreï¼ˆ0ã€œ1ã®ç¢ºç‡ï¼‰
    - 1ã«è¿‘ã„ = äºˆæƒ³ã—ã‚„ã™ã„ãƒ¬ãƒ¼ã‚¹
    - 0ã«è¿‘ã„ = äºˆæƒ³å›°é›£ãªãƒ¬ãƒ¼ã‚¹
    """

    def calculate_predictability_features(self, race_data):
        """
        äºˆæƒ³ã—ã‚„ã™ã•ã‚’åˆ¤å®šã™ã‚‹ç‰¹å¾´é‡

        1. ãƒ‡ãƒ¼ã‚¿å……è¶³ç‡
           - å±•ç¤ºã‚¿ã‚¤ãƒ ãƒ‡ãƒ¼ã‚¿ã®æœ‰ç„¡
           - é¸æ‰‹æˆç¸¾ãƒ‡ãƒ¼ã‚¿ã®å……å®Ÿåº¦
           - ãƒ¢ãƒ¼ã‚¿ãƒ¼æˆç¸¾ãƒ‡ãƒ¼ã‚¿ã®å……å®Ÿåº¦

        2. ãƒ¬ãƒ¼ã‚¹ã®å®‰å®šæ€§
           - ã‚³ãƒ¼ã‚¹åˆ¥å‹ç‡ã®åˆ†æ•£ï¼ˆå°ã•ã„ã»ã©å®‰å®šï¼‰
           - é¸æ‰‹å®ŸåŠ›å·®ï¼ˆå¤§ãã„ã»ã©äºˆæƒ³ã—ã‚„ã™ã„ï¼‰
           - ãƒ¢ãƒ¼ã‚¿ãƒ¼æ€§èƒ½å·®

        3. éå»ã®äºˆæ¸¬ç²¾åº¦
           - åŒæ¡ä»¶ãƒ¬ãƒ¼ã‚¹ã§ã®çš„ä¸­ç‡
           - åŒä¼šå ´ã§ã®çš„ä¸­ç‡

        4. è’ã‚Œã«ãã•æŒ‡æ¨™
           - 1å·è‰‡é€ƒã’ç‡
           - ã‚¤ãƒ³ã‚³ãƒ¼ã‚¹å‹ç‡
           - ä¸‡èˆŸç‡ï¼ˆä½ã„ã»ã©å®‰å®šï¼‰
        """
        features = {
            # ãƒ‡ãƒ¼ã‚¿å……è¶³ç‡
            'exh_data_completeness': ...,
            'racer_data_quality': ...,
            'motor_data_quality': ...,

            # ãƒ¬ãƒ¼ã‚¹å®‰å®šæ€§
            'course_winrate_variance': ...,
            'racer_skill_gap': ...,
            'motor_perf_gap': ...,

            # éå»ç²¾åº¦
            'venue_accuracy': ...,
            'similar_race_accuracy': ...,

            # è’ã‚Œã«ãã•
            'escape_rate': ...,
            'inside_winrate': ...,
            'upset_rate': ...
        }
        return features
```

**å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ãƒ©ãƒ™ãƒ«**:
```python
# éå»ãƒ¬ãƒ¼ã‚¹ã§å®Ÿéš›ã«çš„ä¸­ã—ãŸã‹ï¼ˆ1ï¼‰ã€å¤–ã‚ŒãŸã‹ï¼ˆ0ï¼‰
# ã¾ãŸã¯ã€äºˆæ¸¬ç¢ºç‡ã¨å®Ÿéš›ã®çµæœã®ä¹–é›¢åº¦
```

**è©•ä¾¡æŒ‡æ¨™**:
- Stage1ã‚¹ã‚³ã‚¢ > 0.6 ã®ãƒ¬ãƒ¼ã‚¹ã ã‘ã‚’é¸å®š
- ãã®ãƒ¬ãƒ¼ã‚¹ã®çš„ä¸­ç‡ãŒç›®æ¨™ï¼ˆ40-55%ï¼‰é”æˆ

---

#### 1.2 æœŸå¾…å€¤ãƒ™ãƒ¼ã‚¹ã®æŠ•è³‡æˆ¦ç•¥ï¼ˆ1é€±é–“ï¼‰
**ç›®çš„**: æœŸå¾…å€¤ãƒ—ãƒ©ã‚¹ã®è²·ã„ç›®ã®ã¿è³¼å…¥

**å®Ÿè£…å†…å®¹**:
```python
# src/betting/kelly_strategy.py
class KellyBettingStrategy:
    """
    KellyåŸºæº–ã§ã®æŠ•è³‡æˆ¦ç•¥
    """

    def calculate_expected_value(self, pred_prob, odds):
        """
        æœŸå¾…å€¤ = pred_prob Ã— odds - 1

        Args:
            pred_prob: ãƒ¢ãƒ‡ãƒ«äºˆæ¸¬ç¢ºç‡ï¼ˆæ ¡æ­£æ¸ˆã¿ï¼‰
            odds: ã‚ªãƒƒã‚º

        Returns:
            expected_value: æœŸå¾…å€¤
        """
        return pred_prob * odds - 1

    def kelly_criterion(self, pred_prob, odds, bankroll, fraction=0.25):
        """
        KellyåŸºæº–ã§ã®è³­ã‘é‡‘è¨ˆç®—

        Args:
            pred_prob: å‹ç‡äºˆæ¸¬
            odds: ã‚ªãƒƒã‚º
            bankroll: è³‡é‡‘
            fraction: ãƒªã‚¹ã‚¯èª¿æ•´ï¼ˆ0.25 = 1/4 Kellyï¼‰

        Returns:
            bet_size: è³­ã‘é‡‘
        """
        p = pred_prob
        b = odds - 1  # ç´”åˆ©ç›Šå€ç‡
        q = 1 - p

        # Kelly formula: (bp - q) / b
        kelly_fraction = (b * p - q) / b

        # ãƒ•ãƒ©ã‚¯ã‚·ãƒ§ãƒŠãƒ«Kellyï¼ˆãƒªã‚¹ã‚¯å‰Šæ¸›ï¼‰
        bet_fraction = max(0, kelly_fraction * fraction)

        return bankroll * bet_fraction

    def select_bets(self, race_predictions, odds_data, min_ev=0.05):
        """
        è³¼å…¥ã™ã¹ãè²·ã„ç›®ã‚’é¸å®š

        Args:
            race_predictions: äºˆæ¸¬çµæœ
            odds_data: ã‚ªãƒƒã‚ºãƒ‡ãƒ¼ã‚¿
            min_ev: æœ€å°æœŸå¾…å€¤ï¼ˆ5%ä»¥ä¸Šï¼‰

        Returns:
            selected_bets: è³¼å…¥æ¨å¥¨è²·ã„ç›®ãƒªã‚¹ãƒˆ
        """
        bets = []

        for pred in race_predictions:
            ev = self.calculate_expected_value(pred['prob'], pred['odds'])

            if ev > min_ev:
                bet_size = self.kelly_criterion(
                    pred['prob'],
                    pred['odds'],
                    bankroll=10000,
                    fraction=0.25
                )

                bets.append({
                    'combination': pred['combination'],
                    'pred_prob': pred['prob'],
                    'odds': pred['odds'],
                    'expected_value': ev,
                    'recommended_bet': bet_size
                })

        return sorted(bets, key=lambda x: x['expected_value'], reverse=True)
```

**UIã¸ã®çµ±åˆ**:
```python
# ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ äºˆæƒ³ç”»é¢ã«è¿½åŠ 
st.subheader("ğŸ’° æ¨å¥¨è³¼å…¥æˆ¦ç•¥")

for bet in recommended_bets:
    st.markdown(f"""
    **{bet['combination']}**
    - äºˆæ¸¬ç¢ºç‡: {bet['pred_prob']:.1%}
    - ã‚ªãƒƒã‚º: {bet['odds']:.0f}å€
    - æœŸå¾…å€¤: {bet['expected_value']:.1%}
    - æ¨å¥¨è³¼å…¥é¡: Â¥{bet['recommended_bet']:.0f}
    """)
```

---

### ã€Phase 2ã€‘é«˜å„ªå…ˆï¼ˆ2é€±é–“ï¼‰

#### 2.1 ç‰¹å¾´é‡å¼·åŒ–ï¼ˆ1é€±é–“ï¼‰

**è¿½åŠ ç‰¹å¾´é‡**:
```python
# 1. ãƒ¬ãƒ¼ã‚¹å†…å±•ç¤ºé †ä½
def calc_exhibition_rank_in_race(race_data):
    """å±•ç¤ºã‚¿ã‚¤ãƒ ã®ãƒ¬ãƒ¼ã‚¹å†…é †ä½"""
    race_data['exh_rank_in_race'] = race_data.groupby('race_id')['exhibition_time'].rank()
    return race_data

# 2. Target Encoding
from category_encoders import TargetEncoder

def apply_target_encoding(X_train, y_train, X_test, categorical_cols):
    """
    ã‚«ãƒ†ã‚´ãƒªå¤‰æ•°ã‚’Target Encodingã§æ•°å€¤åŒ–

    ä¾‹: é¸æ‰‹ID â†’ ãã®é¸æ‰‹ã®å¹³å‡å‹ç‡
    """
    encoder = TargetEncoder(cols=categorical_cols)
    X_train_encoded = encoder.fit_transform(X_train, y_train)
    X_test_encoded = encoder.transform(X_test)
    return X_train_encoded, X_test_encoded

# 3. æ½®æ±ã®ç›¸å¯¾çš„å½±éŸ¿
def calc_tide_relative(race_data):
    """
    æ½®æ±ã®å½±éŸ¿ã‚’ç›¸å¯¾åŒ–

    - æº€æ½®æ™‚ã‚’+1ã€å¹²æ½®æ™‚ã‚’-1
    - å ´æ‰€ã”ã¨ã®æ½®æ±å½±éŸ¿åº¦ã‚’è€ƒæ…®
    """
    tide_mapping = {'æº€æ½®': 1.0, 'ä¸Šã’': 0.5, 'ä¸‹ã’': -0.5, 'å¹²æ½®': -1.0}
    race_data['tide_rel'] = race_data['tide_type'].map(tide_mapping)

    # å ´æ‰€ã”ã¨ã®æ½®æ±å½±éŸ¿åº¦ã§é‡ã¿ä»˜ã‘
    venue_tide_impact = {...}  # DBã‹ã‚‰å–å¾—
    race_data['tide_rel_weighted'] = race_data['tide_rel'] * race_data['venue_code'].map(venue_tide_impact)

    return race_data
```

---

#### 2.2 ç¢ºç‡æ ¡æ­£ï¼ˆ3æ—¥ï¼‰

**å®Ÿè£…å†…å®¹**:
```python
from sklearn.calibration import CalibratedClassifierCV
from sklearn.isotonic import IsotonicRegression

class ProbabilityCalibrator:
    """
    äºˆæ¸¬ç¢ºç‡ã®æ ¡æ­£

    ç”Ÿã®ãƒ¢ãƒ‡ãƒ«å‡ºåŠ›ç¢ºç‡ã‚’ã€å®Ÿéš›ã®çš„ä¸­ç¢ºç‡ã«è¿‘ã¥ã‘ã‚‹
    """

    def calibrate_platt(self, model, X_val, y_val):
        """
        Platt Scaling

        ãƒ­ã‚¸ã‚¹ãƒ†ã‚£ãƒƒã‚¯å›å¸°ã§ç¢ºç‡ã‚’æ ¡æ­£
        """
        calibrated = CalibratedClassifierCV(
            model,
            method='sigmoid',
            cv='prefit'
        )
        calibrated.fit(X_val, y_val)
        return calibrated

    def calibrate_isotonic(self, y_true, y_pred):
        """
        Isotonic Regression

        ã‚ˆã‚ŠæŸ”è»Ÿãªæ ¡æ­£ï¼ˆå˜èª¿å¢—åŠ åˆ¶ç´„ã®ã¿ï¼‰
        """
        calibrator = IsotonicRegression(out_of_bounds='clip')
        calibrator.fit(y_pred, y_true)
        return calibrator
```

**åŠ¹æœ**:
- äºˆæ¸¬ç¢ºç‡ 50% â†’ å®Ÿéš›ã®çš„ä¸­ç‡ã‚‚ç´„50%
- KellyåŸºæº–ã§ã®è³­ã‘é‡‘è¨ˆç®—ã®ç²¾åº¦å‘ä¸Š

---

#### 2.3 æ™‚ç³»åˆ—K-fold CVï¼ˆ3æ—¥ï¼‰

**å®Ÿè£…å†…å®¹**:
```python
from sklearn.model_selection import TimeSeriesSplit

def time_series_cross_validation(data, n_splits=5):
    """
    æ™‚ç³»åˆ—ã‚’è€ƒæ…®ã—ãŸã‚¯ãƒ­ã‚¹ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³

    è¨“ç·´ãƒ‡ãƒ¼ã‚¿ã«æœªæ¥æƒ…å ±ãŒæ··å…¥ã—ãªã„ã‚ˆã†ã«åˆ†å‰²
    """
    tscv = TimeSeriesSplit(n_splits=n_splits)

    scores = []
    for train_idx, val_idx in tscv.split(data):
        train_data = data.iloc[train_idx]
        val_data = data.iloc[val_idx]

        # ãƒ¢ãƒ‡ãƒ«å­¦ç¿’
        model = train_model(train_data)

        # è©•ä¾¡
        score = evaluate_model(model, val_data)
        scores.append(score)

    return np.mean(scores), np.std(scores)
```

---

### ã€Phase 3ã€‘ä¸­å„ªå…ˆï¼ˆ2é€±é–“ï¼‰

#### 3.1 è©•ä¾¡æŒ‡æ¨™ã®æ‹¡å……ï¼ˆ1é€±é–“ï¼‰

**è¿½åŠ æŒ‡æ¨™**:
```python
class AdvancedMetrics:
    """
    é«˜åº¦ãªè©•ä¾¡æŒ‡æ¨™
    """

    def precision_at_k(self, y_true, y_pred_proba, k=10):
        """
        ä¸Šä½Kä»¶ã®ç²¾åº¦

        äºˆæ¸¬ç¢ºç‡ä¸Šä½Kä»¶ã®ã†ã¡ã€ä½•ä»¶ãŒçš„ä¸­ã—ãŸã‹
        """
        top_k_indices = np.argsort(y_pred_proba)[-k:]
        return y_true[top_k_indices].mean()

    def recall_at_k(self, y_true, y_pred_proba, k=10):
        """
        ä¸Šä½Kä»¶ã®å†ç¾ç‡

        å®Ÿéš›ã®çš„ä¸­ã®ã†ã¡ã€ä½•%ã‚’ä¸Šä½Kä»¶ã§ã‚«ãƒãƒ¼ã—ãŸã‹
        """
        top_k_indices = np.argsort(y_pred_proba)[-k:]
        return y_true[top_k_indices].sum() / y_true.sum()

    def monthly_roi(self, bet_results):
        """
        æœˆæ¬¡ROIï¼ˆæŠ•è³‡åç›Šç‡ï¼‰

        (ç²å¾—é‡‘é¡ - æŠ•è³‡é‡‘é¡) / æŠ•è³‡é‡‘é¡
        """
        monthly_stats = bet_results.groupby(bet_results['date'].dt.to_period('M')).agg({
            'bet_amount': 'sum',
            'return_amount': 'sum'
        })

        monthly_stats['roi'] = (monthly_stats['return_amount'] - monthly_stats['bet_amount']) / monthly_stats['bet_amount']

        return monthly_stats

    def max_drawdown(self, balance_series):
        """
        æœ€å¤§ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³

        è³‡é‡‘ã®æœ€å¤§ä¸‹è½å¹…
        """
        cummax = balance_series.cummax()
        drawdown = (balance_series - cummax) / cummax
        return drawdown.min()
```

---

#### 3.2 é‹ç”¨æ©Ÿèƒ½ï¼ˆ1é€±é–“ï¼‰

**é€±æ¬¡è‡ªå‹•å†å­¦ç¿’**:
```python
# scripts/weekly_retrain.py
import schedule
import time

def weekly_retrain_job():
    """
    é€±æ¬¡ã§ãƒ¢ãƒ‡ãƒ«ã‚’å†å­¦ç¿’
    """
    print(f"[{datetime.now()}] é€±æ¬¡å†å­¦ç¿’ã‚’é–‹å§‹")

    # 1. æœ€æ–°ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
    data = fetch_latest_data(days=180)

    # 2. ãƒ¢ãƒ‡ãƒ«å­¦ç¿’
    model = train_model(data)

    # 3. è©•ä¾¡
    metrics = evaluate_model(model)

    # 4. æ€§èƒ½ãŒå‘ä¸Šã—ã¦ã„ã‚Œã°ä¿å­˜
    if metrics['accuracy'] > current_best_accuracy:
        model.save('models/latest_model.pkl')
        log_model_update(metrics)

    print(f"[{datetime.now()}] é€±æ¬¡å†å­¦ç¿’ãŒå®Œäº†")

# ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«è¨­å®š
schedule.every().sunday.at("02:00").do(weekly_retrain_job)

while True:
    schedule.run_pending()
    time.sleep(3600)  # 1æ™‚é–“ã”ã¨ã«ãƒã‚§ãƒƒã‚¯
```

**ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°**:
```python
# ui/pages/performance_monitor.py
def render_performance_monitor():
    """
    ãƒ¢ãƒ‡ãƒ«ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°
    """
    st.header("ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°")

    # 1. çš„ä¸­ç‡ã®æ¨ç§»
    st.subheader("çš„ä¸­ç‡ã®æ¨ç§»ï¼ˆé€±æ¬¡ï¼‰")
    fig_accuracy = plot_weekly_accuracy()
    st.plotly_chart(fig_accuracy)

    # 2. å›åç‡ã®æ¨ç§»
    st.subheader("å›åç‡ã®æ¨ç§»ï¼ˆæœˆæ¬¡ï¼‰")
    fig_roi = plot_monthly_roi()
    st.plotly_chart(fig_roi)

    # 3. æœ€å¤§ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³
    st.metric("æœ€å¤§ãƒ‰ãƒ­ãƒ¼ãƒ€ã‚¦ãƒ³", f"{max_dd:.1%}")

    # 4. ã‚¢ãƒ©ãƒ¼ãƒˆ
    if current_accuracy < threshold:
        st.error("âš ï¸ ç²¾åº¦ãŒä½ä¸‹ã—ã¦ã„ã¾ã™ï¼ãƒ¢ãƒ‡ãƒ«å†å­¦ç¿’ã‚’æ¤œè¨ã—ã¦ãã ã•ã„")
```

---

## ğŸš€ å®Ÿè£…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«

### Week 1-2: Phase 1ï¼ˆæœ€å„ªå…ˆï¼‰
- [ ] Stage1: ãƒ¬ãƒ¼ã‚¹é¸åˆ¥ãƒ¢ãƒ‡ãƒ«å®Ÿè£…
- [ ] KellyåŸºæº–æŠ•è³‡æˆ¦ç•¥å®Ÿè£…
- [ ] UIã¸ã®çµ±åˆ

### Week 3-4: Phase 2ï¼ˆé«˜å„ªå…ˆï¼‰
- [ ] ç‰¹å¾´é‡å¼·åŒ–ï¼ˆå±•ç¤ºé †ä½ã€Target Encodingç­‰ï¼‰
- [ ] ç¢ºç‡æ ¡æ­£å®Ÿè£…
- [ ] æ™‚ç³»åˆ—K-fold CVå®Ÿè£…

### Week 5-6: Phase 3ï¼ˆä¸­å„ªå…ˆï¼‰
- [ ] è©•ä¾¡æŒ‡æ¨™æ‹¡å……
- [ ] é€±æ¬¡è‡ªå‹•å†å­¦ç¿’æ©Ÿèƒ½
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°UI

---

## ğŸ“ æ³¨æ„äº‹é …

### å¿…é ˆãƒ«ãƒ¼ãƒ«
1. **æ™‚ç³»åˆ—å³å®ˆ**
   - è¨“ç·´ãƒ‡ãƒ¼ã‚¿ã«æœªæ¥æƒ…å ±ãŒæ··å…¥ã—ãªã„ã“ã¨
   - æ—¥ä»˜é †ã§ãƒ‡ãƒ¼ã‚¿ã‚’åˆ†å‰²
   - ã‚ªãƒƒã‚ºã¯äºˆæ¸¬æ™‚ç‚¹ã§å–å¾—ã§ãã‚‹ã‚‚ã®ã«é™å®š

2. **æ­£è¦åŒ–**
   - player_id, motor_no ã¯å¿…ãšæ­£è¦åŒ–
   - å ´æ‰€ã‚³ãƒ¼ãƒ‰ã€ãƒ¬ãƒ¼ã‚¹ã‚¿ã‚¤ãƒ—ã‚‚ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°

3. **æ¤œè¨¼**
   - SHAPã§ç‰¹å¾´é‡ã®å¯„ä¸ã‚’ç¢ºèª
   - æœªæ¥æƒ…å ±ãŒå«ã¾ã‚Œã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯
   - ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆã§å®Ÿé‹ç”¨ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³

---

## ğŸ¯ ç›®æ¨™é”æˆåŸºæº–

### çŸ­æœŸç›®æ¨™ï¼ˆ2ãƒ¶æœˆï¼‰
- [ ] Stage1ãƒ¢ãƒ‡ãƒ«ã®å®Ÿè£…å®Œäº†
- [ ] Kellyæˆ¦ç•¥ã®å®Ÿè£…å®Œäº†
- [ ] ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆã§çš„ä¸­ç‡30%ä»¥ä¸Š

### ä¸­æœŸç›®æ¨™ï¼ˆ4ãƒ¶æœˆï¼‰
- [ ] çš„ä¸­ç‡40%é”æˆï¼ˆAIé¸å®šãƒ¬ãƒ¼ã‚¹å†…ï¼‰
- [ ] å›åç‡110%é”æˆ
- [ ] è‡ªå‹•é‹ç”¨æ©Ÿèƒ½ã®å®Œæˆ

### é•·æœŸç›®æ¨™ï¼ˆ6ãƒ¶æœˆï¼‰
- [ ] çš„ä¸­ç‡50%ä»¥ä¸Š
- [ ] å›åç‡120%ä»¥ä¸Š
- [ ] å®Œå…¨è‡ªå‹•åŒ–é‹ç”¨
