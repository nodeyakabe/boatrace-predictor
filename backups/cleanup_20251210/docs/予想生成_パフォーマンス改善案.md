# 予想生成 パフォーマンス改善案

## 🚨 現状の問題

### 処理時間
- **144レース全体**: 27分以上
- **1レースあたり**: 11-12秒
- **ユーザー体験**: 非常に遅く、待てない

### ボトルネック箇所

1. **決まり手適性スコア計算**
   - 過去180日間の全レースを集計
   - 1選手あたり数百〜数千レコードを処理
   - 6艇 × 144レース = 864回の重い集計処理

2. **グレード適性スコア計算**
   - 過去365日間の全レースを集計
   - 決まり手より更に重い処理

3. **データベースクエリの繰り返し**
   - 各レースごとに複数回のSELECT文
   - インデックスが効いていても積み重なると遅い

4. **キャッシュ機構の不在**
   - 同じ選手が複数レースに出場していても毎回再計算
   - 同じ会場特性を毎回再取得

## ✅ 改善案（優先度順）

### 🔥 最優先: バッチ処理とキャッシュ

#### 1. 選手データの一括取得とキャッシュ

**現状:**
```python
# 各レースで個別に処理
for race in all_races:
    racer_analyses = self.racer_analyzer.analyze_race_entries(race_id)
    # 同じ選手が別レースにいても再計算
```

**改善後:**
```python
# 1. 今日出場する全選手をリストアップ
all_racers = get_todays_unique_racers(race_ids)

# 2. 一括で選手データを取得してキャッシュ
racer_cache = {}
for racer_number in all_racers:
    racer_cache[racer_number] = {
        'basic_stats': get_racer_basic_stats(racer_number),
        'kimarite_affinity': calculate_kimarite_affinity_batch(racer_number),
        'grade_affinity': calculate_grade_affinity_batch(racer_number)
    }

# 3. レースごとの予想はキャッシュから取得
for race in all_races:
    predictions = predict_from_cache(race, racer_cache, motor_cache)
```

**効果:**
- 処理時間: **27分 → 5-7分** (70%削減)

#### 2. データベースクエリの一括実行

**現状:**
```python
for race in all_races:
    cursor.execute("SELECT ... FROM races WHERE id = ?", (race_id,))
    cursor.execute("SELECT ... FROM entries WHERE race_id = ?", (race_id,))
    cursor.execute("SELECT ... FROM race_conditions WHERE race_id = ?", (race_id,))
```

**改善後:**
```python
# 全レースのデータを一度に取得
races_data = cursor.execute("""
    SELECT r.*, rc.wind_speed, rc.wave_height, rc.wind_direction
    FROM races r
    LEFT JOIN race_conditions rc ON r.id = rc.race_id
    WHERE r.id IN (?, ?, ..., ?)
""", race_ids).fetchall()

# 全エントリーを一度に取得
entries_data = cursor.execute("""
    SELECT * FROM entries WHERE race_id IN (?, ?, ..., ?)
""", race_ids).fetchall()

# メモリ上で整理
races_by_id = organize_by_race_id(races_data, entries_data)
```

**効果:**
- DB往復回数: **432回 → 3回** (99%削減)
- 処理時間: さらに **2-3分削減**

### 🔶 中優先: インデックス最適化

#### 3. データベースインデックスの追加

**必要なインデックス:**
```sql
-- 決まり手適性計算用
CREATE INDEX IF NOT EXISTS idx_race_results_racer_kimarite
ON race_results(racer_number, kimarite, race_id);

-- グレード適性計算用
CREATE INDEX IF NOT EXISTS idx_races_grade_date
ON races(race_grade, race_date);

-- 選手成績検索用（既存確認が必要）
CREATE INDEX IF NOT EXISTS idx_entries_racer_race
ON entries(racer_number, race_id);
```

**効果:**
- クエリ速度: **30-50%高速化**
- 特に決まり手・グレード集計が劇的に改善

### 🔷 低優先: 非同期処理

#### 4. バックグラウンドジョブ化

**現状:**
- UIがフリーズして操作不能
- 進捗が見えない

**改善後:**
```python
# バックグラウンドジョブとして実行
if st.button("今日の予想を生成"):
    job_manager.start_job(
        'prediction_generation',
        worker_script='scripts/worker_prediction_generator.py',
        args=['--date', today]
    )
    st.success("バックグラウンドで予想生成を開始しました")
    st.info("「状況を更新」ボタンで進捗を確認できます")
```

**効果:**
- UI応答性: **即座に操作可能**
- ユーザー体験: **大幅改善**

### 🔹 番外: 段階的生成

#### 5. 必要なレースだけ生成

**アイデア:**
- ユーザーが見るレースだけ予想を生成
- 残りはバックグラウンドで徐々に生成

```python
# 優先度つき生成
high_priority_races = get_sg_g1_races(today)  # SG/G1レース
predict_races(high_priority_races)  # 即座に生成

# 残りはバックグラウンド
background_generate_remaining_races(today)
```

## 📊 改善効果の試算

| 改善施策 | 現状 | 改善後 | 削減率 |
|---------|------|--------|--------|
| **キャッシュ導入** | 27分 | 7分 | 70% |
| **一括クエリ** | 7分 | 4分 | 43% |
| **インデックス** | 4分 | 3分 | 25% |
| **バックグラウンド** | UI凍結 | 即応 | - |

**最終目標:**
- **処理時間**: 27分 → **3分以内**
- **UI応答**: フリーズ → **即座に操作可能**
- **ユーザー体験**: 待てない → **快適**

## 🚀 実装優先順位

1. **即効性が高い**: バックグラウンドジョブ化 (1-2時間)
2. **効果が大きい**: 選手データキャッシュ (3-4時間)
3. **基盤改善**: 一括クエリ化 (4-5時間)
4. **地道な改善**: インデックス追加 (30分)

合計実装時間: **1-2日**

---

**作成日**: 2025-11-27
**バージョン**: 1.0
**関連ファイル**:
- `src/analysis/race_predictor.py`
- `ui/components/workflow_manager.py`
